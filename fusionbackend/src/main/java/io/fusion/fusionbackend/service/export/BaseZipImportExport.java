/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package io.fusion.fusionbackend.service.export;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import io.fusion.fusionbackend.dto.BaseEntityDto;
import io.fusion.fusionbackend.exception.InvalidException;
import io.fusion.fusionbackend.service.storage.BaseClient;
import org.springframework.web.multipart.MultipartFile;

import java.io.BufferedOutputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;
import java.util.zip.ZipOutputStream;

public abstract class BaseZipImportExport {

    private static final Long MAX_FILE_SIZE_ZIP = BaseClient.convertMegabytesToBytes(10L);
    private static final int BUFFER_SIZE = 4096;

    public static ObjectMapper getNewObjectMapper() {
        return new ObjectMapper().findAndRegisterModules()
                .disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)
                .setSerializationInclusion(JsonInclude.Include.NON_NULL);
    }

    public static <T> T fileContentToDtoSet(final byte[] fileContent, TypeReference<T> x) throws IOException {
        ObjectMapper objectMapper = BaseZipImportExport.getNewObjectMapper();
        return objectMapper.readerFor(x).readValue(fileContent);
    }

    public static <T extends BaseEntityDto> List<T> toSortedList(final Set<T> dtos) {
        return dtos.stream().sorted((o1, o2) -> (int)(o1.getId() - o2.getId())).collect(Collectors.toList());
    }

    public static void checkFileSize(final MultipartFile zipFile) {
        if (zipFile == null) {
            throw new NullPointerException();
        } else if  (zipFile.getSize() > MAX_FILE_SIZE_ZIP) {
            throw new IllegalArgumentException("Zip file is too large");
        }
    }

    protected void addFileToZipOutputStream(final ZipOutputStream zipOutputStream,
                                                      final String filename,
                                                      final byte[] data) throws IOException {
        ZipEntry entry = new ZipEntry(filename);
        entry.setComment("autogenerated by industry fusion server");
        zipOutputStream.putNextEntry(entry);
        zipOutputStream.write(data);
    }

    protected byte[] readZipEntry(final ZipEntry entry, final ZipInputStream zipInputStream) throws IOException {
        if (entry.isDirectory()) {
            throw new InvalidException();
        }

        byte[] buffer = new byte[BUFFER_SIZE];
        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
        BufferedOutputStream out = new BufferedOutputStream(byteArrayOutputStream);

        int count;
        while ((count = zipInputStream.read(buffer)) != -1) {
            out.write(buffer, 0, count);
        }

        out.close();
        return byteArrayOutputStream.toByteArray();
    }

    protected void importEntitiesFromZip(final Long companyId,
                                         final Long factorySiteId,
                                         final InputStream inputStream) throws IOException {

        int totalEntitySkippedCount = 0;
        try (ZipInputStream zipInputStream = new ZipInputStream(inputStream)) {

            ZipEntry entry;
            while ((entry = zipInputStream.getNextEntry()) != null) {
                totalEntitySkippedCount += importZipEntry(entry, zipInputStream, companyId, factorySiteId)
                        .totalEntitySkippedCount;
            }
        }
        inputStream.close();

        /*if (totalEntitySkippedCount > 0) {
            throw new RuntimeException("Import succeeded partially. " + totalEntitySkippedCount
                    + " entities were ignored as their id already existed");
        }*/
    }

    protected abstract ImportResult importZipEntry(final ZipEntry entry, final ZipInputStream zipInputStream,
                                                   final Long companyId, final Long factorySiteId) throws IOException;
}
